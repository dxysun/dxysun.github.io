
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>java面试题之基础篇(一) | 迎着朝阳的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="dxysun">
    

    
    <meta name="description" content="总结一下java面试题-基础篇">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试题之基础篇(一)">
<meta property="og:url" content="https://github.com/dxysun/2018/07/15/javaForInterview/index.html">
<meta property="og:site_name" content="迎着朝阳的博客">
<meta property="og:description" content="总结一下java面试题-基础篇">
<meta property="og:locale">
<meta property="article:published_time" content="2018-07-15T06:38:53.000Z">
<meta property="article:modified_time" content="2018-07-16T12:10:20.000Z">
<meta property="article:author" content="dxysun">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="/atom.xml" title="迎着朝阳的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/%02.css">
<link rel="stylesheet" href="/.css">

<meta name="generator" content="Hexo 5.3.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="迎着朝阳的博客" title="迎着朝阳的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="迎着朝阳的博客">迎着朝阳的博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:github.com/dxysun">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/15/javaForInterview/" title="java面试题之基础篇(一)" itemprop="url">java面试题之基础篇(一)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="dxysun" target="_blank" itemprop="author">dxysun</a>
		
  <p class="article-time">
    <time datetime="2018-07-15T06:38:53.000Z" itemprop="datePublished"> Published 2018-07-15</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">说说&amp;和&amp;&amp;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8byte%E4%B8%8A%EF%BC%8C%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8long%E4%B8%8A%EF%BC%8C%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8String%E4%B8%8A"><span class="toc-number">2.</span> <span class="toc-text">switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#short-s1-1-s1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99-short-s1-1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99"><span class="toc-number">3.</span> <span class="toc-text">short s1&#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">4.</span> <span class="toc-text">char型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E6%96%BC%E5%87%A0"><span class="toc-number">5.</span> <span class="toc-text">用最有效率的方法算出2乘以8等於几?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">静态变量和实例变量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AAstatic%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9Estatic%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">是否可以从一个static方法内部发出对非static方法的调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E4%B8%8Eint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">Integer与int的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-round-11-5-%E7%AD%89%E6%96%BC%E5%A4%9A%E5%B0%91-Math-round-11-5-%E7%AD%89%E6%96%BC%E5%A4%9A%E5%B0%91"><span class="toc-number">10.</span> <span class="toc-text">Math.round(11.5)等於多少?Math.round(-11.5)等於多少?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Overload%E5%92%8COverride%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FOverloaded%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Overload"><span class="toc-number">11.1.</span> <span class="toc-text">Overload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Override"><span class="toc-number">11.2.</span> <span class="toc-text">Override</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0-implements-%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%85%B7%E4%BD%93%E7%B1%BB-concreteclass-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%9C%89%E9%9D%99%E6%80%81%E7%9A%84main%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">接口是否可继承接口?抽象类是否可实现(implements)接口?抽象类是否可继承具体类(concreteclass)?抽象类中是否可以有静态的main方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">Java中实现多态的机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract-class%E5%92%8Cinterface%E8%AF%AD%E6%B3%95%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">abstract class和interface语法上有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract%E7%9A%84method%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFstatic-%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFnative%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFsynchronized"><span class="toc-number">15.</span> <span class="toc-text">abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E5%AE%83%E7%9A%84%E5%8C%85%E5%90%AB%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">内部类可以引用它的包含类的成员吗？有没有什么限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-s-%E2%80%9CHello%E2%80%9D-s-s-%E2%80%9Cworld-%E2%80%9D-%E8%BF%99%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8C%E5%8E%9F%E5%A7%8B%E7%9A%84String%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E5%88%B0%E5%BA%95%E5%8F%98%E4%BA%86%E6%B2%A1%E6%9C%89%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">String s &#x3D; “Hello”;s &#x3D; s + “world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">ArrayList和Vector的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">HashMap和Hashtable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%92%8C-Map%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">List和 Map区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-Set-Map%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E8%87%AACollection%E6%8E%A5%E5%8F%A3"><span class="toc-number">21.</span> <span class="toc-text">List,Set, Map是否继承自Collection接口?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E3%80%81Map%E3%80%81Set%E4%B8%89%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">List、Map、Set三个接口，存取元素时，各有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E5%87%BAArrayList-Vector-LinkedList%E7%9A%84%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">23.</span> <span class="toc-text">说出ArrayList,Vector,LinkedList的存储性能和特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E6%8E%89%E4%B8%80%E4%B8%AAVector%E9%9B%86%E5%90%88%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">24.</span> <span class="toc-text">去掉一个Vector集合中重复的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E5%92%8CCollections%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">25.</span> <span class="toc-text">Collection和Collections的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%87%8C%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%87%8D%E5%A4%8D%E4%B8%8E%E5%90%A6%E5%91%A2-%E6%98%AF%E7%94%A8-%E8%BF%98%E6%98%AFequals-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?是用&#x3D;&#x3D;还是equals()?它们有何区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">你所知道的集合类都有哪些？主要方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AAStringObject%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BFString%E7%B1%BB"><span class="toc-number">28.</span> <span class="toc-text">String s &#x3D; new String(“xyz”);创建了几个StringObject？是否可以继承String类?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">29.</span> <span class="toc-text">String和StringBuffer的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E8%BF%99%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%80%E5%85%B1%E5%88%9B%E5%BB%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9AString-s-%E2%80%9Da%E2%80%9D-%E2%80%9Db%E2%80%9D-%E2%80%9Dc%E2%80%9D-%E2%80%9Dd%E2%80%9D"><span class="toc-number">30.</span> <span class="toc-text">下面这条语句一共创建了多少个对象：String s&#x3D;”a”+”b”+”c”+”d”;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-%E9%87%8C%E6%9C%89%E4%B8%80%E4%B8%AAreturn%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B4%A7%E8%B7%9F%E5%9C%A8%E8%BF%99%E4%B8%AAtry%E5%90%8E%E7%9A%84finally-%E9%87%8C%E7%9A%84code%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%9C%A8return%E5%89%8D%E8%BF%98%E6%98%AF%E5%90%8E"><span class="toc-number">31.</span> <span class="toc-text">try {}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">32.</span> <span class="toc-text">final, finally, finalize的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">运行时异常与一般异常有何异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error%E5%92%8Cexception%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">34.</span> <span class="toc-text">error和exception有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E3%80%82"><span class="toc-number">35.</span> <span class="toc-text">简单说说Java中的异常处理机制的简单原理和应用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">Java 中堆和栈有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B0%86-int-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%AF%A5%E5%80%BC%E5%A4%A7%E4%BA%8E-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-hashCode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E4%B8%8E-a-equals-b-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">39.</span> <span class="toc-text">字节流与字符流的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E6%88%96%E8%80%85%E8%AF%B7%E8%A7%A3%E9%87%8ASerializable%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">40.</span> <span class="toc-text">什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">41.</span> <span class="toc-text">描述一下JVM加载class文件的原理机制?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heap%E5%92%8Cstack%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">42.</span> <span class="toc-text">heap和stack有什么区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89GC"><span class="toc-number">43.</span> <span class="toc-text">GC是什么?为什么要有GC?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E5%8E%9F%E7%90%86%E3%80%82%E5%B9%B6%E8%80%83%E8%99%912%E7%A7%8D%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E3%80%82"><span class="toc-number">44.</span> <span class="toc-text">垃圾回收的优点和原理。并考虑2种回收机制。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%AF%E4%BB%A5%E9%A9%AC%E4%B8%8A%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E4%B8%BB%E5%8A%A8%E9%80%9A%E7%9F%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%EF%BC%8Cthrow-%E5%92%8C-throws-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">46.</span> <span class="toc-text">Java 中，throw 和 throws 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="toc-number">47.</span> <span class="toc-text">java中会存在内存泄漏吗，请简单描述。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">48.</span> <span class="toc-text">Java中的泛型是什么? 使用泛型的好处是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">Java的泛型是如何工作的 ? 什么是类型擦除 ?如何工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%8A%8AList%E4%BC%A0%E9%80%92%E7%BB%99%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%97List%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">你可以把List传递给一个接受List参数的方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%AA%E6%A3%80%E6%9F%A5%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-number">51.</span> <span class="toc-text">如何阻止Java中的类型未检查的警告?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADList%E5%92%8C%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8BList%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">52.</span> <span class="toc-text">Java中List和原始类型List之间的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%90%97"><span class="toc-number">53.</span> <span class="toc-text">Array中可以用泛型吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AE%A9%E5%AE%83%E8%83%BD%E6%8E%A5%E5%8F%97%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">54.</span> <span class="toc-text">如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%A8%A1%E6%9D%BF%E5%92%8Cjava%E6%B3%9B%E5%9E%8B%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">C++模板和java泛型之间有何不同？</span></a></li></ol>
		
		</div>
		
		<p>总结一下java面试题-基础篇</p>
<a id="more"></a>
<h3 id="说说-amp-和-amp-amp-的区别"><a href="#说说-amp-和-amp-amp-的区别" class="headerlink" title="说说&amp;和&amp;&amp;的区别"></a>说说&amp;和&amp;&amp;的区别</h3><p>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</p>
<p>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，</p>
<p>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。</p>
<h3 id="switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a>switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</h3><p>在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，java1.7之前它们不能作用于swtich语句中。<br>但是Java1.7之后，switch语句能作用在String上了<br>switch支持的类型:char, byte, short, int, Character, Byte, Short, Integer, String, or an enum</p>
<h3 id="short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="short s1= 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a>short s1= 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</h3><p>第一问，s1+1是int类型，而等号左边的是short类型，所以需要强转<br>第二问，没有错</p>
<p>对于short s1= 1; s1 = s1 + 1;由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。<br>对于short s1= 1; s1 += 1;由于 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p>
<h3 id="char型变量中能不能存贮一个中文汉字-为什么"><a href="#char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char型变量中能不能存贮一个中文汉字?为什么?"></a>char型变量中能不能存贮一个中文汉字?为什么?</h3><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。<br>补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p>
<h3 id="用最有效率的方法算出2乘以8等於几"><a href="#用最有效率的方法算出2乘以8等於几" class="headerlink" title="用最有效率的方法算出2乘以8等於几?"></a>用最有效率的方法算出2乘以8等於几?</h3><p>2&lt;&lt; 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2&lt;&lt; 3。</p>
<blockquote>
<p>&lt;&lt; 左移 &gt;&gt; 带符号右移 &gt;&gt;&gt; 无符号右移</p>
</blockquote>
<h3 id="使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h3><p>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的</p>
<h3 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h3><p>在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。</p>
<p>在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p>
<h3 id="是否可以从一个static方法内部发出对非static方法的调用？"><a href="#是否可以从一个static方法内部发出对非static方法的调用？" class="headerlink" title="是否可以从一个static方法内部发出对非static方法的调用？"></a>是否可以从一个static方法内部发出对非static方法的调用？</h3><p>不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。</p>
<h3 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h3><p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况。</p>
<blockquote>
<p>java 的8种原始基本类型:byte,short,int,long,float,double,boolean,char</p>
</blockquote>
<p>例如：要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</p>
<p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p>
<p>另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<h3 id="Math-round-11-5-等於多少-Math-round-11-5-等於多少"><a href="#Math-round-11-5-等於多少-Math-round-11-5-等於多少" class="headerlink" title="Math.round(11.5)等於多少?Math.round(-11.5)等於多少?"></a>Math.round(11.5)等於多少?Math.round(-11.5)等於多少?</h3><p>Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应。</p>
<p>例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.ceil(11.6)的结果为11,Math.ceil(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</p>
<h3 id="Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型"><a href="#Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型?"></a>Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型?</h3><h4 id="Overload"><a href="#Overload" class="headerlink" title="Overload"></a>Overload</h4><p>Overload是重载的意思，Override是覆盖的意思，也就是重写。</p>
<p>重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同），与返回类型和修饰符无关。</p>
<p>至于Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</p>
<p>Overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：</p>
<p>1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；</p>
<p>2、不能通过访问权限、返回类型、抛出的异常进行重载；</p>
<p>3、方法的异常类型和数目不会对重载造成影响；</p>
<p>4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p>
<h4 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h4><p>重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</p>
<p>override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：</p>
<p>1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</p>
<p>2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；</p>
<p>3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</p>
<p>4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<h3 id="接口是否可继承接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concreteclass-抽象类中是否可以有静态的main方法？"><a href="#接口是否可继承接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concreteclass-抽象类中是否可以有静态的main方法？" class="headerlink" title="接口是否可继承接口?抽象类是否可实现(implements)接口?抽象类是否可继承具体类(concreteclass)?抽象类中是否可以有静态的main方法？"></a>接口是否可继承接口?抽象类是否可实现(implements)接口?抽象类是否可继承具体类(concreteclass)?抽象类中是否可以有静态的main方法？</h3><p>接口可以继承接口。<br>抽象类可以实现(implements)接口，抽象类可以继承具体类。<br>抽象类中可以有静态的main方法。</p>
<blockquote>
<p>只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。</p>
</blockquote>
<p>只要记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。</p>
<h3 id="Java中实现多态的机制是什么？"><a href="#Java中实现多态的机制是什么？" class="headerlink" title="Java中实现多态的机制是什么？"></a>Java中实现多态的机制是什么？</h3><p>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p>
<h3 id="abstract-class和interface语法上有什么区别"><a href="#abstract-class和interface语法上有什么区别" class="headerlink" title="abstract class和interface语法上有什么区别?"></a>abstract class和interface语法上有什么区别?</h3><p>1.抽象类可以有构造方法，接口中不能有构造方法(java8 中可以有默认方法和静态方法，默认方法用defult修饰)。<br>2.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。<br>4.抽象类中的抽象方法的访问类型可以是public，protected和默认类型，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。<br>5.抽象类中可以包含静态方法，java8之前接口中不能包含静态方法，java8及其之后可以<br>6.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型<br>7.一个类可以实现多个接口，但只能继承一个抽象类。</p>
<h3 id="abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized"><a href="#abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized" class="headerlink" title="abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?"></a>abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</h3><p>abstract的method不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！</p>
<p>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现；例如，在windows用c语言实现的，所以，查看jdk的源代码，可以发现FileOutputStream的open方法的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private native void open(Stringname) throwsFileNotFoundException;</span><br></pre></td></tr></table></figure>
<p>如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。</p>
<p>synchronized不能与abstract合用，synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。</p>
<h3 id="内部类可以引用它的包含类的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类的成员吗？有没有什么限制？</h3><p>完全可以。如果不是静态内部类，那没有什么限制！</p>
<p>如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">static int x;</span><br><span class="line">static class Inner&#123;</span><br><span class="line">        void test()&#123;</span><br><span class="line">              System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-s-“Hello”-s-s-“world-”-这两行代码执行后，原始的String对象中的内容到底变了没有？"><a href="#String-s-“Hello”-s-s-“world-”-这两行代码执行后，原始的String对象中的内容到底变了没有？" class="headerlink" title="String s = “Hello”;s = s + “world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？"></a>String s = “Hello”;s = s + “world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</h3><p>没有。因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</p>
<p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。<br>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">private String s;</span><br><span class="line">...</span><br><span class="line">public Demo &#123;</span><br><span class="line">s &#x3D; &quot;Initial Value&quot;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而非</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; new String(“Initial Value”);</span><br></pre></td></tr></table></figure>
<p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。<br>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。<br>至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即StringBuffer。</p>
<h3 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h3><p>这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是与HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList与Vector的区别主要包括两个方面：.<br>（1）同步性：<br>Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
<p>（2）数据增长：<br>ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，ArrayList与Vector的初始空间大小都是10，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。</p>
<p>总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。</p>
<h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。</p>
<p>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p>
<p>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</p>
<p>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</p>
<p>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供同步。</p>
<p>就HashMap与HashTable主要从三方面来说。<br>一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现<br>二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的<br>三.值：只有HashMap可以让你将空值作为一个表的条目的key或value</p>
<h3 id="List和-Map区别"><a href="#List和-Map区别" class="headerlink" title="List和 Map区别?"></a>List和 Map区别?</h3><p>一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</p>
<h3 id="List-Set-Map是否继承自Collection接口"><a href="#List-Set-Map是否继承自Collection接口" class="headerlink" title="List,Set, Map是否继承自Collection接口?"></a>List,Set, Map是否继承自Collection接口?</h3><p>List，Set是，Map不是</p>
<h3 id="List、Map、Set三个接口，存取元素时，各有什么特点？"><a href="#List、Map、Set三个接口，存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set三个接口，存取元素时，各有什么特点？"></a>List、Map、Set三个接口，存取元素时，各有什么特点？</h3><p>首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个共同的父接口，叫Collection。Set里面不允许有重复的元素，即不能有两个相等（注意，不是仅仅是相同）的对象，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，不能细说要取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。</p>
<p>List表示有先后顺序的集合，注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obj)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(intindex,Obj)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以用Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。</p>
<p>Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key所对应的value。另外，也可以获得所有的key的集合，还可以获得所有的value的集合，还可以获得key和value组合成的Map.Entry对象的集合。</p>
<p>List以特定次序来持有元素，可有重复元素。Set无法拥有重复元素,内部排序。Map保存key-value值，value可多值。</p>
<h3 id="说出ArrayList-Vector-LinkedList的存储性能和特性"><a href="#说出ArrayList-Vector-LinkedList的存储性能和特性" class="headerlink" title="说出ArrayList,Vector,LinkedList的存储性能和特性"></a>说出ArrayList,Vector,LinkedList的存储性能和特性</h3><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，索引就变慢了，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<p>LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。</p>
<h3 id="去掉一个Vector集合中重复的元素"><a href="#去掉一个Vector集合中重复的元素" class="headerlink" title="去掉一个Vector集合中重复的元素"></a>去掉一个Vector集合中重复的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vector newVector &#x3D; new Vector();</span><br><span class="line"></span><br><span class="line">For (int i&#x3D;0;i&lt;vector.size();i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       Object obj &#x3D; vector.get(i);</span><br><span class="line">       if(!newVector.contains(obj);</span><br><span class="line"></span><br><span class="line">             newVector.add(obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>还有一种简单的方式，利用了Set不允许重复元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet set &#x3D; new HashSet(vector);</span><br></pre></td></tr></table></figure>
<h3 id="Collection和Collections的区别。"><a href="#Collection和Collections的区别。" class="headerlink" title="Collection和Collections的区别。"></a>Collection和Collections的区别。</h3><p>Collection是集合类的上级接口，继承他的接口主要有Set和List.</p>
<p>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h3 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?是用==还是equals()?它们有何区别?"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?是用==还是equals()?它们有何区别?</h3><p>==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。</p>
<p>equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。</p>
<p>比如：两条new语句创建了两个对象，然后用a/b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。</p>
<h3 id="你所知道的集合类都有哪些？主要方法？"><a href="#你所知道的集合类都有哪些？主要方法？" class="headerlink" title="你所知道的集合类都有哪些？主要方法？"></a>你所知道的集合类都有哪些？主要方法？</h3><p>最常用的集合类是 List 和 Map。 List的具体实现包括 ArrayList和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List适用于按数值索引访问元素的情形。</p>
<p>Map 提供了一个更通用的元素存储方法。 Map集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p>
<p>它们都有增删改查的方法。</p>
<p>对于set，大概的方法是add,remove, contains等</p>
<p>对于map，大概的方法就是put,remove，contains等</p>
<p>List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value，这个自由发挥，也不是考记方法的能力，这些编程过程中会有提示，结合他们三者的不同说一下用法就行。</p>
<h3 id="String-s-new-String-“xyz”-创建了几个StringObject？是否可以继承String类"><a href="#String-s-new-String-“xyz”-创建了几个StringObject？是否可以继承String类" class="headerlink" title="String s = new String(“xyz”);创建了几个StringObject？是否可以继承String类?"></a>String s = new String(“xyz”);创建了几个StringObject？是否可以继承String类?</h3><p>两个或一个都有可能，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。new String每写一遍，就创建一个新的对象，它使用常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过”xyz”，那么这里就不会创建”xyz”了，直接从缓冲区拿，这时创建了一个StringObject；但如果以前没有用过”xyz”，那么此时就会创建一个对象并放入缓冲区，这种情况它创建两个对象。至于String类是否继承，答案是否定的，因为String默认final修饰，是不可继承的。</p>
<h3 id="String和StringBuffer的区别"><a href="#String和StringBuffer的区别" class="headerlink" title="String和StringBuffer的区别"></a>String和StringBuffer的区别</h3><p>JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串可以进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。</p>
<blockquote>
<p>StringBuffer是线程安全的，StringBuilder不是线程安全的</p>
</blockquote>
<h3 id="下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”"><a href="#下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”" class="headerlink" title="下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;"></a>下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</h3><p>对于如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;a&quot;;</span><br><span class="line"></span><br><span class="line">String s2 &#x3D; s1 + &quot;b&quot;;</span><br><span class="line"></span><br><span class="line">String s3 &#x3D; &quot;a&quot; + &quot;b&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(s2 &#x3D;&#x3D; &quot;ab&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(s3 &#x3D;&#x3D; &quot;ab&quot;);</span><br></pre></td></tr></table></figure>
<p>第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期再去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。</p>
<p>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D;&quot;a&quot; + &quot;b&quot; +&quot;c&quot; + &quot;d&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(s&#x3D;&#x3D; &quot;abcd&quot;);</span><br></pre></td></tr></table></figure>
<p>最终打印的结果应该为true。</p>
<h3 id="try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="try {}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>try {}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</h3><p>我们知道finally{}中的语句是一定会执行的，那么这个可能正常脱口而出就是return之前，return之后可能就出了这个方法了，鬼知道跑哪里去了，但更准确的应该是在return中间执行，请看下面程序代码的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[]args) &#123;</span><br><span class="line">       System.out.println(new Test().test());</span><br><span class="line">    &#125;</span><br><span class="line">    static int test()</span><br><span class="line">    &#123;</span><br><span class="line">       int x &#x3D; 1;</span><br><span class="line">       try</span><br><span class="line">       &#123;</span><br><span class="line">          return x;</span><br><span class="line">       &#125;</span><br><span class="line">       finally</span><br><span class="line">       &#123;</span><br><span class="line">          ++x;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>———执行结果 ———</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。</p>
<blockquote>
<p>fianlly里面如果有return就会覆盖try里面的return结果<br>如上例，finally里如果是<code>return ++x;</code>执行结果就是2</p>
</blockquote>
<h3 id="final-finally-finalize的区别。"><a href="#final-finally-finalize的区别。" class="headerlink" title="final, finally, finalize的区别。"></a>final, finally, finalize的区别。</h3><p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。内部类要访问局部变量，局部变量必须定义成final类型。</p>
<p>finally是异常处理语句结构的一部分，表示总是执行。</p>
<p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。但是JVM不保证此方法总被调用</p>
<h3 id="运行时异常与一般异常有何异同？"><a href="#运行时异常与一般异常有何异同？" class="headerlink" title="运行时异常与一般异常有何异同？"></a>运行时异常与一般异常有何异同？</h3><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<h3 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别?"></a>error和exception有什么区别?</h3><p>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h3 id="简单说说Java中的异常处理机制的简单原理和应用。"><a href="#简单说说Java中的异常处理机制的简单原理和应用。" class="headerlink" title="简单说说Java中的异常处理机制的简单原理和应用。"></a>简单说说Java中的异常处理机制的简单原理和应用。</h3><p>异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。</p>
<p>Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：</p>
<p>Error和Exception，Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有奔溃了，例如，说内存溢出和线程死锁等系统问题。</p>
<p>Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常：</p>
<p>系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件挂掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；</p>
<p>普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</p>
<p>java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。</p>
<h3 id="Java-中堆和栈有什么区别？"><a href="#Java-中堆和栈有什么区别？" class="headerlink" title="Java 中堆和栈有什么区别？"></a>Java 中堆和栈有什么区别？</h3><p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<p>栈：在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。</p>
<p>堆：堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。</p>
<h3 id="能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h3><p>我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化，int 类型的高 24 位将会被丢弃，因为byte 类型的范围是从-128到127</p>
<h3 id="a-hashCode-有什么用？与-a-equals-b-有什么关系？"><a href="#a-hashCode-有什么用？与-a-equals-b-有什么关系？" class="headerlink" title="a.hashCode() 有什么用？与 a.equals(b) 有什么关系？"></a>a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</h3><p>hashCode() 方法对应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p>
<h3 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h3><p>要把一段二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一段二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p>
<p>计算机中的一切最终都是二进制的字节形式存在。对于经常用到的中文字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，Java专门提供了字符流包装类。</p>
<p>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。</p>
<p>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。</p>
<h3 id="什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"><a href="#什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。" class="headerlink" title="什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"></a>什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</h3><p>我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输。</p>
<p>但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现方法，implements Serializable只是为了标注该对象是可被序列化的。</p>
<p>例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输，被传输的对象就必须实现Serializable接口。</p>
<h3 id="描述一下JVM加载class文件的原理机制"><a href="#描述一下JVM加载class文件的原理机制" class="headerlink" title="描述一下JVM加载class文件的原理机制?"></a>描述一下JVM加载class文件的原理机制?</h3><p>JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
<h3 id="heap和stack有什么区别。"><a href="#heap和stack有什么区别。" class="headerlink" title="heap和stack有什么区别。"></a>heap和stack有什么区别。</h3><p>java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。</p>
<p>堆是与栈作用不同的内存，一般用于存放不在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。</p>
<h3 id="GC是什么-为什么要有GC"><a href="#GC是什么-为什么要有GC" class="headerlink" title="GC是什么?为什么要有GC?"></a>GC是什么?为什么要有GC?</h3><p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p>
<h3 id="垃圾回收的优点和原理。并考虑2种回收机制。"><a href="#垃圾回收的优点和原理。并考虑2种回收机制。" class="headerlink" title="垃圾回收的优点和原理。并考虑2种回收机制。"></a>垃圾回收的优点和原理。并考虑2种回收机制。</h3><p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。</p>
<p>垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</p>
<p>回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p>
<h3 id="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的””。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<h3 id="Java-中，throw-和-throws-有什么区别"><a href="#Java-中，throw-和-throws-有什么区别" class="headerlink" title="Java 中，throw 和 throws 有什么区别"></a>Java 中，throw 和 throws 有什么区别</h3><p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个Exception，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new IllegalArgumentException(“XXXXXXXXX″)</span><br></pre></td></tr></table></figure>
<p>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<h3 id="java中会存在内存泄漏吗，请简单描述。"><a href="#java中会存在内存泄漏吗，请简单描述。" class="headerlink" title="java中会存在内存泄漏吗，请简单描述。"></a>java中会存在内存泄漏吗，请简单描述。</h3><p>先解释什么是内存泄漏：所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证当对象不再被引用的时候，对象将自动被垃圾回收器从内存中清除掉。</p>
<p>由于Java使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达，那么GC也是可以回收它们的。</p>
<p>java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。</p>
<h3 id="Java中的泛型是什么-使用泛型的好处是什么"><a href="#Java中的泛型是什么-使用泛型的好处是什么" class="headerlink" title="Java中的泛型是什么? 使用泛型的好处是什么?"></a>Java中的泛型是什么? 使用泛型的好处是什么?</h3><p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>好处：</p>
<p>1、类型安全，提供编译期间的类型检测</p>
<p>2、前后兼容</p>
<p>3、泛化代码,代码可以更多的重复利用</p>
<p>4、性能较高，用GJ(泛型JAVA)编写的代码可以为java编译器和虚拟机带来更多的类型信息，这些信息对java程序做进一步优化提供条件。</p>
<h3 id="Java的泛型是如何工作的-什么是类型擦除-如何工作？"><a href="#Java的泛型是如何工作的-什么是类型擦除-如何工作？" class="headerlink" title="Java的泛型是如何工作的 ? 什么是类型擦除 ?如何工作？"></a>Java的泛型是如何工作的 ? 什么是类型擦除 ?如何工作？</h3><p>1、类型检查：在生成字节码之前提供类型检查</p>
<p>2、类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）</p>
<p>3、如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决</p>
<p>4、如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换</p>
<p>类型擦除：</p>
<p>所有类型参数都用他们的限定类型替换：</p>
<p>比如T-&gt;Object ? extends BaseClass-&gt;BaseClass</p>
<p>如何工作：</p>
<p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</p>
<h3 id="你可以把List传递给一个接受List参数的方法吗？"><a href="#你可以把List传递给一个接受List参数的方法吗？" class="headerlink" title="你可以把List传递给一个接受List参数的方法吗？"></a>你可以把List<String>传递给一个接受List<Object>参数的方法吗？</h3><p>对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以 List<String>应当可以用在需要List<Object>的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储String s。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objectList;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; stringList;</span><br><span class="line"></span><br><span class="line">objectList &#x3D; stringList; &#x2F;&#x2F;compilation error incompatible types</span><br></pre></td></tr></table></figure>
<h3 id="如何阻止Java中的类型未检查的警告"><a href="#如何阻止Java中的类型未检查的警告" class="headerlink" title="如何阻止Java中的类型未检查的警告?"></a>如何阻止Java中的类型未检查的警告?</h3><p>如果你把泛型和原始类型混合起来使用，例如下列代码，java 5的javac编译器会产生类型未检查的警告，例如</p>
<p>List<String> rawList = new ArrayList()</p>
<p>注意: Hello.java使用了未检查或称为不安全的操作;</p>
<p>这种警告可以使用@SuppressWarnings(“unchecked”)注解来屏蔽。</p>
<h3 id="Java中List和原始类型List之间的区别"><a href="#Java中List和原始类型List之间的区别" class="headerlink" title="Java中List和原始类型List之间的区别?"></a>Java中List<Object>和原始类型List之间的区别?</h3><p>原始类型和带参数类型<Object>之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。</p>
<p>这道题的考察点在于对泛型中原始类型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List<String>传递给接受 List<Object>的方法，因为会产生编译错误。</p>
<h3 id="Array中可以用泛型吗"><a href="#Array中可以用泛型吗" class="headerlink" title="Array中可以用泛型吗?"></a>Array中可以用泛型吗?</h3><p>这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p>
<h3 id="如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型"><a href="#如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型" class="headerlink" title="如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?"></a>如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</h3><p>编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。最简单的情况下，一个泛型方法可能会像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   public V put(K key, V value) &#123;</span><br><span class="line"></span><br><span class="line">   return cahe.put(key,value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-模板和java泛型之间有何不同？"><a href="#C-模板和java泛型之间有何不同？" class="headerlink" title="C++模板和java泛型之间有何不同？"></a>C++模板和java泛型之间有何不同？</h3><p>java泛型实现根植于“类型消除”这一概念。当源代码被转换为Java虚拟机字节码时，这种技术会消除参数化类型。有了Java泛型，我们可以做的事情也并没有真正改变多少；他只是让代码变得漂亮些。鉴于此，Java泛型有时也被称为“语法糖”。</p>
<p>这和 C++模板截然不同。在 C++中，模板本质上就是一套宏指令集，只是换了个名头，编译器会针对每种类型创建一份模板代码的副本。</p>
<p>由于架构设计上的差异，Java泛型和C++模板有很多不同点：</p>
<p>C++模板可以使用int等基本数据类型。Java则不行，必须转而使用Integer。</p>
<p>在Java中，可以将模板的参数类型限定为某种特定类型。</p>
<p>在C++中，类型参数可以实例化，但java不支持。</p>
<p>在Java中，类型参数不能用于静态方法(?)和变量，因为它们会被不同类型参数指定的实例共享。在C++，这些类时不同的，因此类型参数可以用于静态方法和静态变量。</p>
<p>在Java中，不管类型参数是什么，所有的实例变量都是同一类型。类型参数会在运行时被抹去。在C++中，类型参数不同，实例变量也不同。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://github.com/dxysun/2018/07/15/javaForInterview/" data-title="java面试题之基础篇(一) | 迎着朝阳的博客" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/07/15/javaForInterviewWeb/" title="java面试题之Web篇">
  <strong>上一篇：</strong><br/>
  <span>
  java面试题之Web篇</span>
</a>
</div>


<div class="next">
<a href="/2018/07/14/javaForConcurrent2/"  title="java备忘录之并发（二）">
 <strong>下一篇：</strong><br/> 
 <span>java备忘录之并发（二）
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">说说&amp;和&amp;&amp;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8byte%E4%B8%8A%EF%BC%8C%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8long%E4%B8%8A%EF%BC%8C%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8String%E4%B8%8A"><span class="toc-number">2.</span> <span class="toc-text">switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#short-s1-1-s1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99-short-s1-1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99"><span class="toc-number">3.</span> <span class="toc-text">short s1&#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">4.</span> <span class="toc-text">char型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E6%96%BC%E5%87%A0"><span class="toc-number">5.</span> <span class="toc-text">用最有效率的方法算出2乘以8等於几?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">静态变量和实例变量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AAstatic%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9Estatic%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">是否可以从一个static方法内部发出对非static方法的调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E4%B8%8Eint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">Integer与int的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-round-11-5-%E7%AD%89%E6%96%BC%E5%A4%9A%E5%B0%91-Math-round-11-5-%E7%AD%89%E6%96%BC%E5%A4%9A%E5%B0%91"><span class="toc-number">10.</span> <span class="toc-text">Math.round(11.5)等於多少?Math.round(-11.5)等於多少?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Overload%E5%92%8COverride%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FOverloaded%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Overload"><span class="toc-number">11.1.</span> <span class="toc-text">Overload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Override"><span class="toc-number">11.2.</span> <span class="toc-text">Override</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0-implements-%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%85%B7%E4%BD%93%E7%B1%BB-concreteclass-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%9C%89%E9%9D%99%E6%80%81%E7%9A%84main%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">接口是否可继承接口?抽象类是否可实现(implements)接口?抽象类是否可继承具体类(concreteclass)?抽象类中是否可以有静态的main方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">Java中实现多态的机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract-class%E5%92%8Cinterface%E8%AF%AD%E6%B3%95%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">abstract class和interface语法上有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract%E7%9A%84method%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFstatic-%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFnative%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFsynchronized"><span class="toc-number">15.</span> <span class="toc-text">abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E5%AE%83%E7%9A%84%E5%8C%85%E5%90%AB%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">内部类可以引用它的包含类的成员吗？有没有什么限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-s-%E2%80%9CHello%E2%80%9D-s-s-%E2%80%9Cworld-%E2%80%9D-%E8%BF%99%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8C%E5%8E%9F%E5%A7%8B%E7%9A%84String%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E5%88%B0%E5%BA%95%E5%8F%98%E4%BA%86%E6%B2%A1%E6%9C%89%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">String s &#x3D; “Hello”;s &#x3D; s + “world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">ArrayList和Vector的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">HashMap和Hashtable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%92%8C-Map%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">List和 Map区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-Set-Map%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E8%87%AACollection%E6%8E%A5%E5%8F%A3"><span class="toc-number">21.</span> <span class="toc-text">List,Set, Map是否继承自Collection接口?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E3%80%81Map%E3%80%81Set%E4%B8%89%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">List、Map、Set三个接口，存取元素时，各有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E5%87%BAArrayList-Vector-LinkedList%E7%9A%84%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">23.</span> <span class="toc-text">说出ArrayList,Vector,LinkedList的存储性能和特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E6%8E%89%E4%B8%80%E4%B8%AAVector%E9%9B%86%E5%90%88%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">24.</span> <span class="toc-text">去掉一个Vector集合中重复的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E5%92%8CCollections%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">25.</span> <span class="toc-text">Collection和Collections的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%87%8C%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%87%8D%E5%A4%8D%E4%B8%8E%E5%90%A6%E5%91%A2-%E6%98%AF%E7%94%A8-%E8%BF%98%E6%98%AFequals-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?是用&#x3D;&#x3D;还是equals()?它们有何区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">你所知道的集合类都有哪些？主要方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AAStringObject%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BFString%E7%B1%BB"><span class="toc-number">28.</span> <span class="toc-text">String s &#x3D; new String(“xyz”);创建了几个StringObject？是否可以继承String类?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">29.</span> <span class="toc-text">String和StringBuffer的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E8%BF%99%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%80%E5%85%B1%E5%88%9B%E5%BB%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9AString-s-%E2%80%9Da%E2%80%9D-%E2%80%9Db%E2%80%9D-%E2%80%9Dc%E2%80%9D-%E2%80%9Dd%E2%80%9D"><span class="toc-number">30.</span> <span class="toc-text">下面这条语句一共创建了多少个对象：String s&#x3D;”a”+”b”+”c”+”d”;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-%E9%87%8C%E6%9C%89%E4%B8%80%E4%B8%AAreturn%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B4%A7%E8%B7%9F%E5%9C%A8%E8%BF%99%E4%B8%AAtry%E5%90%8E%E7%9A%84finally-%E9%87%8C%E7%9A%84code%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%9C%A8return%E5%89%8D%E8%BF%98%E6%98%AF%E5%90%8E"><span class="toc-number">31.</span> <span class="toc-text">try {}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">32.</span> <span class="toc-text">final, finally, finalize的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">运行时异常与一般异常有何异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error%E5%92%8Cexception%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">34.</span> <span class="toc-text">error和exception有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E3%80%82"><span class="toc-number">35.</span> <span class="toc-text">简单说说Java中的异常处理机制的简单原理和应用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">Java 中堆和栈有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B0%86-int-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%AF%A5%E5%80%BC%E5%A4%A7%E4%BA%8E-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-hashCode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E4%B8%8E-a-equals-b-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">39.</span> <span class="toc-text">字节流与字符流的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E6%88%96%E8%80%85%E8%AF%B7%E8%A7%A3%E9%87%8ASerializable%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">40.</span> <span class="toc-text">什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">41.</span> <span class="toc-text">描述一下JVM加载class文件的原理机制?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heap%E5%92%8Cstack%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">42.</span> <span class="toc-text">heap和stack有什么区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89GC"><span class="toc-number">43.</span> <span class="toc-text">GC是什么?为什么要有GC?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E5%8E%9F%E7%90%86%E3%80%82%E5%B9%B6%E8%80%83%E8%99%912%E7%A7%8D%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E3%80%82"><span class="toc-number">44.</span> <span class="toc-text">垃圾回收的优点和原理。并考虑2种回收机制。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%AF%E4%BB%A5%E9%A9%AC%E4%B8%8A%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E4%B8%BB%E5%8A%A8%E9%80%9A%E7%9F%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%EF%BC%8Cthrow-%E5%92%8C-throws-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">46.</span> <span class="toc-text">Java 中，throw 和 throws 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="toc-number">47.</span> <span class="toc-text">java中会存在内存泄漏吗，请简单描述。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">48.</span> <span class="toc-text">Java中的泛型是什么? 使用泛型的好处是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">Java的泛型是如何工作的 ? 什么是类型擦除 ?如何工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%8A%8AList%E4%BC%A0%E9%80%92%E7%BB%99%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%97List%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">你可以把List传递给一个接受List参数的方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%AA%E6%A3%80%E6%9F%A5%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-number">51.</span> <span class="toc-text">如何阻止Java中的类型未检查的警告?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADList%E5%92%8C%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8BList%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">52.</span> <span class="toc-text">Java中List和原始类型List之间的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%90%97"><span class="toc-number">53.</span> <span class="toc-text">Array中可以用泛型吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AE%A9%E5%AE%83%E8%83%BD%E6%8E%A5%E5%8F%97%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">54.</span> <span class="toc-text">如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%A8%A1%E6%9D%BF%E5%92%8Cjava%E6%B3%9B%E5%9E%8B%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">C++模板和java泛型之间有何不同？</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/spring官方文档/" title="spring官方文档">spring官方文档<sup>8</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/java/" title="java">java<sup>54</sup></a></li>
			
		
			
				<li><a href="/tags/linux/" title="linux">linux<sup>34</sup></a></li>
			
		
			
				<li><a href="/tags/centos/" title="centos">centos<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/springboot/" title="springboot">springboot<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ubuntu/" title="ubuntu">ubuntu<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/hadoop/" title="hadoop">hadoop<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/spring/" title="spring">spring<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/nginx/" title="nginx">nginx<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/spark/" title="spark">spark<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/mybatis/" title="mybatis">mybatis<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/maven/" title="maven">maven<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/hdfs/" title="hdfs">hdfs<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/dubbo/" title="dubbo">dubbo<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/kafka/" title="kafka">kafka<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Hbase/" title="Hbase">Hbase<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/sql/" title="sql">sql<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://majorkevin.xyz/blog/" target="_blank" title="朋友的博客">朋友的博客</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m dxysun. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2020 
		
		<a href="/about" target="_blank" title="dxysun">dxysun</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
